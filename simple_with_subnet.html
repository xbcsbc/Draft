<!DOCTYPE html>
<meta charset="utf-8">
<style>

    .links line {
        stroke: #999;
        stroke-opacity: 0.6;
    }

    .nodes circle {
        stroke: #fff;
        stroke-width: 1.5px;
    }

</style>
<svg width="960" height="600"></svg>
<script src="script/d3.v4.js"></script>
<script>

    var svg = d3.select("svg"),
        width = +svg.attr("width"),
        height = +svg.attr("height");

    var color = d3.scaleOrdinal(d3.schemeCategory20);

    //subnets:[
    //  {id: [String], nodes: [Array], links: [Array]}
    // ]
    //nodes:[
    //  {id: [String], group: [Number], power: [Number], is_attacked: [Boolean]}
    // ]
    //links:[
    //  {source: [String], target: [String], value: [Number], is_bad: [Boolean]}
    // ]
    var graph = {
        "nodes": [],
        "links": []
    };

    var M = 8;
    var N = 48;

    // node
    for(let i = 0; i < M + N; i++)
    {
        graph.nodes.push({id: i, group: 0, power: Math.random() * 8 + 3, is_attacked: false});
    }

    // link
    for(let i = 0; i < M + N; i++){
        let aUsed = [];
        for(let j = 0; j < 8; j++){
            let r = Math.floor((Math.random() * (M + N)) % (M + N + 1));
            while(graph.nodes[r] in aUsed || r === i)	r = Math.floor((Math.random() * (M + N)) % (M + N + 1));
            aUsed.push(graph.nodes[r]);
            graph.links.push({source: i, target: r, value: 10, is_bad: false});
        }
    }


    var simulation = d3.forceSimulation()
        .force("link", d3.forceLink().id(function(d) { return d.id; }).strength(0).distance(100))
        .force("chcenterarge", d3.forceManyBody())
        .force("", d3.forceCenter(width / 2, height / 2))
        .force("collision", d3.forceCollide(function (d) { return d.power; }))
        .force("radial", d3.forceRadial(Math.min(width, height) / 6, width / 2, height / 2));

    var link = svg.append("g")
        .attr("class", "links")
        .selectAll("line")
        .data(graph.links)
        .enter().append("line")
        .attr("style", function (d, i) {
            return d.is_bad ? "display:none;" : "display:block;stroke:#B7E7F5";
        })
        .attr("id", function (d, i) {
            return 'link' + d.source + 'to' + d.target;
        });

    var node = svg.append("g")
        .attr("class", "nodes")
        .selectAll("circle")
        .data(graph.nodes)
        .enter().append("circle")
        .attr("r", function (d, i) {
            return d.power;
        })
        .attr("fill", function (d, i) {
            return d.is_attacked ? "#FFCC33" : "#A6ECAB";
        } )
        .attr("id", function(d) {return 'node' + d.id;})
        .on("click", beAttacked)
        .call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));

    simulation
        .nodes(graph.nodes)
        .on("tick", ticked);

    simulation.force("link")
        .links(graph.links);

    function ticked() {
        link
            .attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });

        node
            .attr("cx", function(d) { return d.x; })
            .attr("cy", function(d) { return d.y; });

        svg.selectAll('g.links').selectAll('line')
            .attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });
    }

    function dragstarted(d) {
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }

    function dragged(d) {
        d.fx = d3.event.x;
        d.fy = d3.event.y;
    }

    function dragended(d) {
        if (!d3.event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    }

    function beAttacked(d, i) {
        if(d.is_attacked)   return;
        d3.select(this).attr("fill", "#FFCC33");
        d.is_attacked = true;
        graph.links.forEach(function (item, index, array) {
            if(item.target.id === d.id)
            {
                item.is_bad = true;
                d3.selectAll('#link' + item.source.id + 'to' + item.target.id).remove();
                // .attr("style", "display:none;");
                array.splice(index, 1);
                simulation.force("link")
                    .links(graph.links);
                // simulation.force("center", d3.forceCenter(0, 0));
                simulation.restart();
            }
        });
        let cnt = 0;
        graph.nodes.forEach(function (item, index, array) {
            if(cnt < 2 && item.is_attacked && item !== d)
            {
                if(Math.random() < 0.33)
                {
                    graph.links.push({source: d, target: item, value: 10, is_bad: false});
                    simulation.force("link")
                        .links(graph.links);
                    svg.selectAll('g.links')
                        .append('line')
                        .datum({source: d, target: item, value: 10, is_bad: false})
                        .attr("style","display:block;stroke:#FFCB6B")
                        .attr("id", 'link' + d.id + 'to' + item.id);
                    simulation.restart();
                    cnt += 1;
                }
            }
        })
    }

</script>